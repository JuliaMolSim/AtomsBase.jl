var documenterSearchIndex = {"docs":
[{"location":"testing/#Testing-against-the-AtomsBase-interface","page":"Testing against the AtomsBase interface","title":"Testing against the AtomsBase interface","text":"","category":"section"},{"location":"testing/","page":"Testing against the AtomsBase interface","title":"Testing against the AtomsBase interface","text":"The AtomsBaseTesting package provides a few utility functions to test downstream packages for having properly implemented the AtomsBase interface. The tests are probably not complete, but they should be a good start ... and as always PRs are welcome.","category":"page"},{"location":"testing/","page":"Testing against the AtomsBase interface","title":"Testing against the AtomsBase interface","text":"Two functions are provided, namely make_test_system to generate standard FlexibleSystem test systems and test_approx_eq for testing approximate equality between AtomsBase systems (of not necessarily the same type). The basic idea of the functions is to use make_test_system to obtain a test system, construct an identical system in a downstream library and then use test_approx_eq to check they are actually equal.","category":"page"},{"location":"testing/","page":"Testing against the AtomsBase interface","title":"Testing against the AtomsBase interface","text":"For usage examples see the tests of ExtXYZ, AtomsIO, Chemfiles and ASEconnect.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The main abstract type introduced in AtomsBase is AbstractSystem{D}. The D parameter indicates the number of spatial dimensions in the system. In most circumstances  particles have a position and D then indicates the dimension of a position vector.  (A particle may have additional properties such as mass, charge, etc but those are  normally ignored in the interpretation of D.) Contained inside the system are species, which may have an arbitrary type, accessible via the species_type(system) function. While AtomsBase provides some default species types (e.g. Atom and AtomView for standard atoms) in principle no constraints are made on this species type.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The main power of the interface comes from predictable behavior of several core functions to access information about a system and the species. Various categories of such functions are described below.","category":"page"},{"location":"overview/#System-geometry","page":"Overview","title":"System geometry","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Functions that need to be dispatched:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"bounding_box(::AbstractSystem{D})::SVector{D,SVector{D,<:Unitful.Length}}: returns D vectors of length D that describe the \"box\" in which the system lives\nboundary_conditions(::AbstractSystem{D})::SVector{D,BoundaryCondition}): returns a vector of length D of BoundaryCondition objects to describe what happens at the edges of the box","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Functions that will work automatically:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"periodicity: returns a vector of length D of Bools for whether each dimension of the system has periodic boundary conditions\nn_dimensions: returns D, the number of spatial dimensions of the system","category":"page"},{"location":"overview/#Iteration-and-Indexing-over-systems","page":"Overview","title":"Iteration and Indexing over systems","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There is a presumption of the ability to somehow extract an individual component (e.g. a single atom or molecule) of this system, though there are no constraints on the type of this component. To achieve this, an AbstractSystem object is expected to implement the Julia interfaces for iteration and indexing in order to access representations of individual components of the system. Some default dispatches of parts of these interfaces are already included, so the minimal set of functions to dispatch in a concrete implementation is Base.getindex and Base.length, though it may be desirable to customize additional behavior depending on context.","category":"page"},{"location":"overview/#System-state-and-properties","page":"Overview","title":"System state and properties","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The only required properties to be specified of the system is the species and implementations of standard functions accessing the properties of the species, currently","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Geometric information: position, velocity, n_dimensions\nAtomic information: atomic_symbol, atomic_mass, atomic_number, element\nAtomic and system property accessors: getindex, haskey, get, keys, pairs","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Based on these methods respective equivalent methods acting on an AbstractSystem will be automatically available, e.g. using the iteration interface of the AbstractSystem (see above). Most of the property accessors on the AbstractSystem also have indexed signatures to extract data from a particular species directly, for example:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"position(sys, i) # position of `i`th particle in `sys`","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, this syntax only supports linear indexing.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To simplify working with AtomsBase, default implementations for systems composed of atoms are provided (see Tutorial).","category":"page"},{"location":"overview/#Struct-of-Arrays-vs.-Array-of-Structs","page":"Overview","title":"Struct-of-Arrays vs. Array-of-Structs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The \"struct-of-arrays\" (SoA) vs. \"array-of-structs\" (AoS) is a common design dilemma in representations of systems such as these. We have deliberately designed this interface to be agnostic to how a concrete implementation chooses to structure its data. Some specific notes regarding how implementations might differ for these two paradigms are included below.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A way to think about this broadly is that the difference amounts to the ordering of function calls. For example, to get the position of a single particle in an AoS implementation, the explicit function chaining would be position(getindex(sys)) (i.e. extract the single struct representing the particle of interest and query its position), while for SoA, one should prefer an implementation like getindex(position(sys)) (extract the array of positions, then index into it for a single particle). The beauty of an abstract interface in Julia is that these details can be, in large part, abstracted away through method dispatch such that the end user sees the same expected behavior irrespective of how things are implemented \"under the hood\".","category":"page"},{"location":"overview/#Boundary-Conditions","page":"Overview","title":"Boundary Conditions","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we include support for defining boundary conditions. Currently included are Periodic and DirichletZero. There should be one boundary condition specified for each spatial dimension represented.","category":"page"},{"location":"overview/#Atomic-system","page":"Overview","title":"Atomic system","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Since we anticipate atomic systems to be a commonly needed representation, AtomsBase provides two flexible implementations for this setting. One implementation follows the struct-of-arrays approach introducing the AtomView type to conveniently expose atomic data. The more flexible implementation is based on an array-of-structs approach and can be easily customised, e.g. by adding custom properties or by swapping the underlying Atom struct by a custom one. In both cases the respective datastructures can be used either fully or in parts in downstream packages and we hope these to develop into universally useful types within the Julia ecosystem over time.","category":"page"},{"location":"overview/#Struct-of-Arrays-/-FastSystem","page":"Overview","title":"Struct of Arrays / FastSystem","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The file src/fast_system.jl contains an implementation of AtomsBase based on the struct-of-arrays approach. All species data is stored as plain arrays, but for convenience indexing of individual atoms is supported by a light-weight AtomView. See the implementation files as well as the tests for how these can be used.","category":"page"},{"location":"overview/#Atoms-and-FlexibleSystem","page":"Overview","title":"Atoms and FlexibleSystem","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"A flexible implementation of the interface is provided by the FlexibleSystem and the Atom structs for representing atomic systems. These are discussed in detail in Tutorial.","category":"page"},{"location":"apireference/","page":"API reference","title":"API reference","text":"CurrentModule = AtomsBase","category":"page"},{"location":"apireference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"apireference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"Pages = [\"apireference.md\"]","category":"page"},{"location":"apireference/#System-properties","page":"API reference","title":"System properties","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"boundary_conditions\nbounding_box\nchemical_formula\nelement_symbol\nisinfinite\nn_dimensions\nperiodicity\nspecies_type\natomkeys\nhasatomkey\nvisualize_ascii","category":"page"},{"location":"apireference/#AtomsBase.boundary_conditions","page":"API reference","title":"AtomsBase.boundary_conditions","text":"boundary_conditions(sys::AbstractSystem{D})\n\nReturn a vector of length D of BoundaryCondition objects, one for each direction described by bounding_box(sys).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.bounding_box","page":"API reference","title":"AtomsBase.bounding_box","text":"bounding_box(sys::AbstractSystem{D})\n\nReturn a vector of length D of vectors of length D that describe the \"box\" in which the system sys is defined.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.chemical_formula","page":"API reference","title":"AtomsBase.chemical_formula","text":"Returns the chemical formula of an AbstractSystem as a string.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.element_symbol","page":"API reference","title":"AtomsBase.element_symbol","text":"element_symbol(system)\nelement_symbol(system, index)\nelement_symbol(species)\n\nReturn the symbols corresponding to the elements of the atoms. Note that this may be different than atomic_symbol for cases where atomic_symbol is chosen to be more specific (i.e. designate a special atom).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.isinfinite","page":"API reference","title":"AtomsBase.isinfinite","text":"Returns true if the given system is infinite\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.n_dimensions","page":"API reference","title":"AtomsBase.n_dimensions","text":"n_dimensions(::AbstractSystem)\nn_dimensions(atom)\n\nReturn number of dimensions.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.periodicity","page":"API reference","title":"AtomsBase.periodicity","text":"Return vector indicating whether the system is periodic along a dimension.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.species_type","page":"API reference","title":"AtomsBase.species_type","text":"species_type(::AbstractSystem)\n\nReturn the type used to represent a species or atom.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.atomkeys","page":"API reference","title":"AtomsBase.atomkeys","text":"atomkeys(sys::AbstractSystem)\n\nReturn the atomic properties, which are available in all atoms of the system.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.hasatomkey","page":"API reference","title":"AtomsBase.hasatomkey","text":"hasatomkey(system::AbstractSystem, x::Symbol)\n\nReturns true whether the passed property available in all atoms of the passed system.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.visualize_ascii","page":"API reference","title":"AtomsBase.visualize_ascii","text":"Build an ASCII representation of the passed atomistic structure. The string may be empty if the passed structure could not be represented (structure not supported or invalid).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Species-/-atom-properties","page":"API reference","title":"Species / atom properties","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"atomic_mass\natomic_number\natomic_symbol\nvelocity\nposition\nelement","category":"page"},{"location":"apireference/#AtomsBase.atomic_mass","page":"API reference","title":"AtomsBase.atomic_mass","text":"atomic_mass(sys::AbstractSystem)\natomic_mass(sys::AbstractSystem, i)\natomic_mass(species)\n\nVector of atomic masses in the system sys or the atomic mass of a particular species / the ith species in sys. The elements are <: Unitful.Mass.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.atomic_number","page":"API reference","title":"AtomsBase.atomic_number","text":"atomic_number(sys::AbstractSystem)\natomic_number(sys::AbstractSystem, i)\natomic_number(species)\n\nVector of atomic numbers in the system sys or the atomic number of a particular species / the ith species in sys.\n\nThe intention is that atomic_number carries the meaning of identifying the type of a species (e.g. the element for the case of an atom), whereas atomic_symbol may return a more unique identifier. For example for a deuterium atom this may be :D while atomic_number is still 1.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.atomic_symbol","page":"API reference","title":"AtomsBase.atomic_symbol","text":"atomic_symbol(sys::AbstractSystem)\natomic_symbol(sys::AbstractSystem, i)\natomic_symbol(species)\n\nVector of atomic symbols in the system sys or the atomic symbol of a particular species / the ith species in sys.\n\nThe intention is that atomic_number carries the meaning of identifying the type of a species (e.g. the element for the case of an atom), whereas atomic_symbol may return a more unique identifier. For example for a deuterium atom this may be :D while atomic_number is still 1.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.velocity","page":"API reference","title":"AtomsBase.velocity","text":"velocity(sys::AbstractSystem{D})\nvelocity(sys::AbstractSystem, index)\nvelocity(species)\n\nReturn a vector of velocities of every particle in the system sys. Return type should be a vector of vectors each containing D elements that are <:Unitful.Velocity. If an index is passed or the action is on a species, return only the velocity of the referenced species. Returned value of the function may be missing.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Base.position","page":"API reference","title":"Base.position","text":"position(sys::AbstractSystem{D})\nposition(sys::AbstractSystem, index)\nposition(species)\n\nReturn a vector of positions of every particle in the system sys. Return type should be a vector of vectors each containing D elements that are <:Unitful.Length. If an index is passed or the action is on a species, return only the position of the referenced species / species on that index.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.element","page":"API reference","title":"AtomsBase.element","text":"The element corresponding to a species/atom (or missing).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Atom-and-system-constructors","page":"API reference","title":"Atom and system constructors","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"Atom\nAtomView\nFlexibleSystem\nAbstractSystem\natomic_system\nisolated_system\nperiodic_system","category":"page"},{"location":"apireference/#AtomsBase.Atom","page":"API reference","title":"AtomsBase.Atom","text":"Atom(identifier::AtomId, position::AbstractVector; kwargs...)\nAtom(identifier::AtomId, position::AbstractVector, velocity::AbstractVector; kwargs...)\nAtom(; atomic_number, position, velocity=zeros(D)u\"bohr/s\", kwargs...)\n\nConstruct an atomic located at the cartesian coordinates position with (optionally) the given cartesian velocity. Note that AtomId = Union{Symbol,AbstractString,Integer}.\n\nSupported kwargs include atomic_symbol, atomic_number, atomic_mass, charge, multiplicity as well as user-specific custom properties.\n\n\n\n\n\nAtom(atom::Atom; kwargs...)\n\nUpdate constructor. Construct a new Atom, by amending the data contained in the passed atom object. Supported kwargs include atomic_symbol, atomic_number, atomic_mass, charge, multiplicity as well as user-specific custom properties.\n\nExamples\n\nConstruct a standard hydrogen atom located at the origin\n\njulia> hydrogen = Atom(:H, zeros(3)u\"Å\")\n\nand now amend its charge and atomic mass\n\njulia> Atom(atom; atomic_mass=1.0u\"u\", charge=-1.0u\"e_au\")\n\n\n\n\n\n","category":"type"},{"location":"apireference/#AtomsBase.AtomView","page":"API reference","title":"AtomsBase.AtomView","text":"AtomView{S<:AbstractSystem}\n\nSpecies type for atoms of systems implemented as struct-of-arrays. Can be queried with the same API than for other species, like Atom.\n\nSee FastSystem for an example of system using AtomView as its species type.\n\nExample\n\njulia> system = FastSystem(atoms, box, boundary_conditions);\n\njulia> atom = system[2]\nAtomView(C, atomic_number = 6, atomic_mass = 12.011 u):\n    position          : [0.75,0.75,0.75]u\"Å\"\n\njulia> atom isa AtomView{typeof(system)}\ntrue\n\njulia> atomic_symbol(atom)\n:C\n\n\n\n\n\n","category":"type"},{"location":"apireference/#AtomsBase.FlexibleSystem","page":"API reference","title":"AtomsBase.FlexibleSystem","text":"FlexibleSystem(particles, bounding_box, boundary_conditions; kwargs...)\nFlexibleSystem(particles; bounding_box, boundary_conditions, kwargs...)\n\nConstruct a flexible system, a versatile data structure for atomistic systems, which puts an emphasis on flexibility rather than speed.\n\n\n\n\n\nFlexibleSystem(system; kwargs...)\n\nUpdate constructor. See AbstractSystem for details.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#AtomsBase.AbstractSystem","page":"API reference","title":"AtomsBase.AbstractSystem","text":"AbstractSystem{D}\n\nA D-dimensional system.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#AtomsBase.atomic_system","page":"API reference","title":"AtomsBase.atomic_system","text":"atomic_system(atoms::AbstractVector, bounding_box, boundary_conditions; kwargs...)\n\nConstruct a FlexibleSystem using the passed atoms and boundary box and conditions. Extra kwargs are stored as custom system properties.\n\nExamples\n\nConstruct a hydrogen molecule in a box, which is periodic only in the first two dimensions\n\njulia> bounding_box = [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]]u\"Å\"\njulia> boundary_conditions = [Periodic(), Periodic(), DirichletZero()]\njulia> hydrogen = atomic_system([:H => [0, 0, 1.]u\"bohr\",\n                                 :H => [0, 0, 3.]u\"bohr\"],\n                                  bounding_box, boundary_conditions)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.isolated_system","page":"API reference","title":"AtomsBase.isolated_system","text":"isolated_system(atoms::AbstractVector; kwargs...)\n\nConstruct a FlexibleSystem by placing the passed atoms into an infinite vacuum (standard setup for modelling molecular systems). Extra kwargs are stored as custom system properties.\n\nExamples\n\nConstruct a hydrogen molecule\n\njulia> hydrogen = isolated_system([:H => [0, 0, 1.]u\"bohr\", :H => [0, 0, 3.]u\"bohr\"])\n\n\n\n\n\n","category":"function"},{"location":"apireference/#AtomsBase.periodic_system","page":"API reference","title":"AtomsBase.periodic_system","text":"periodic_system(atoms::AbstractVector, bounding_box; fractional=false, kwargs...)\n\nConstruct a FlexibleSystem with all boundaries of the bounding_box periodic (standard setup for modelling solid-state systems). If fractional is true, atom coordinates are given in fractional (and not in Cartesian) coordinates. Extra kwargs are stored as custom system properties.\n\nExamples\n\nSetup a hydrogen molecule inside periodic BCs:\n\njulia> bounding_box = [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]]u\"Å\"\njulia> hydrogen = periodic_system([:H => [0, 0, 1.]u\"bohr\",\n                                   :H => [0, 0, 3.]u\"bohr\"],\n                                  bounding_box)\n\nSetup a silicon unit cell using fractional positions\n\njulia> bounding_box = 10.26 / 2 * [[0, 0, 1], [1, 0, 1], [1, 1, 0]]u\"bohr\"\njulia> silicon = periodic_system([:Si =>  ones(3)/8,\n                                  :Si => -ones(3)/8],\n                                 bounding_box, fractional=true)\n\n\n\n\n\n","category":"function"},{"location":"#AtomsBase","page":"Home","title":"AtomsBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julian abstract interface for atomic structures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"AtomsBase is an abstract interface for representation of atomic geometries in Julia. It aims to be a lightweight means of facilitating interoperability between various tools including ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chemical simulation engines:\nDFTK.jl (density-functional theory)\nMolly.jl (molecular dynamics)\nIntegration with third party-libraries:\nASEconvert.jl (integration with the Atomistic Simulation Environment)\nI/O with standard file formats (.cif, .xyz, ...)\nE.g. AtomIO.jl\nautomatic differentiation and machine learning systems\nChemistryFeaturization.jl (featurization of atomic systems)\nnumerical tools: sampling, integration schemes, etc.\nvisualization (e.g. plot recipes)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, the design philosophy is to be as lightweight as possible with a small set of required function dispatches to make adopting the interface easy. We also provide a couple of standard flexible implementations of the interface that we envision to be broadly applicable. If features beyond these are required we encourage developers to open PRs or provide their own implementations. For more on how to use the package, see the documentation.","category":"page"},{"location":"#Packages-using-AtomsBase","page":"Home","title":"Packages using AtomsBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following (not all yet-registered) packages currently make use of AtomsBase:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ASEPotential\nASEconvert\nAtomIO: I/O for atomic structures, also wraps some ASE functionality\nAtomistic: integrated workflow for MD simulations, part of CESMIX\nAutoBZCore.jl: Brillouin-zone integration\nBFPIS\nChemistryFeaturization: Interface for featurization of atomic structures for input into machine learning models, part of Chemellia\nDFTK: density functional theory simulations\nExtXYZ: Parser for extended XYZ files\nInteratomicPotentials: implementations of a variety of interatomic potentials, also part of CESMIX\nMolly: molecular dynamics simulations\nXtals: I/O and structure representation for crystals","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page gives an overview of using AtomsBase in practice and introduces the conventions followed across the AtomsBase ecosystem. It serves as a reference for both users interested in doing something with an AbstractSystem object as well as developers wishing to integrate their code with AtomsBase.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the examples we will mostly draw on the case of atomistic systems using the FlexibleSystem data structure. See Overview for a more general perspective of the AtomsBase interface. In practice we expect that the Atom and FlexibleSystem data structure we focus on here should provide good defaults for most purposes.","category":"page"},{"location":"tutorial/#High-level-introduction","page":"Tutorial","title":"High-level introduction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main purpose of AtomsBase is to conveniently pass atomistic data between Julia packages. For example the following snippet loads an extxyz file using AtomsIO and returns it as an AtomsBase-compatible system (in data):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using AtomsIO\ndata = load_system(\"Si.extxyz\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next we use ASEconvert to convert this system to python, such that we can make use of the atomistic simulation environment (ASE) to form a (2, 1, 1) supercell, which is afterwards converted back to Julia (by forming another AtomsBase-compatible system).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ASEconvert\nsupercell = pyconvert(AbstractSystem, data * pytuple((2, 1, 1)))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally the supercell is passed to DFTK, where we attach pseudopotentials and run a PBE calculation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DFTK\ncell_with_pseudos = attach_psp(supercell, Si=\"hgh/pbe/si-q4\")\nmodel = model_PBE(cell_with_pseudos)\nbasis = PlaneWaveBasis(model, Ecut=30, kgrid=(5, 5, 5)\nself_consistent_field(basis).energy.total","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For more high-level examples see also:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The DFTK documentation page on AtomsBase.\nThe AtomsIO documentation","category":"page"},{"location":"tutorial/#Atom-interface-and-conventions","page":"Tutorial","title":"Atom interface and conventions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An Atom object can be constructed just by passing an identifier (e.g. symbol like :C, atomic number like 6) and a vector of positions as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\natom = Atom(:C, [0, 1, 2.]u\"bohr\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This automatically fills the atom with standard data such as the atomic mass. See also the reference of the Atom function for more ways to construct an atom.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Such data can be accessed using the AtomsBase interface functions, such as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atomic_mass(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atomic_symbol(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atomic_number(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"position(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"velocity(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See src/atom.jl and the respective API documentation for details. Notice in particular that atomic_number will the element, i.e. the type of an atom, whereas atomic_symbol may be more specific and may e.g. uniquely specify a precise atom in the structure. An example could be a deuterium atom","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\ndeuterium = Atom(1, atomic_symbol=:D, [0, 1, 2.]u\"bohr\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An equivalent dict-like interface based on keys, haskey, get and pairs is also available. For example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"keys(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atom[:atomic_symbol]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pairs(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This interface seamlessly generalises to working with user-specific atomic properties as will be discussed next.","category":"page"},{"location":"tutorial/#Optional-atomic-properties","page":"Tutorial","title":"Optional atomic properties","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Custom properties can be easily attached to an Atom by supplying arbitrary keyword arguments upon construction. For example to attach a pseudopotential for using the structure with DFTK, construct the atom as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\natom = Atom(:C, [0, 1, 2.]u\"bohr\", pseudopotential=\"hgh/lda/c-q4\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which will make the pseudopotential identifier available as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atom[:pseudopotential]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that such custom properties are fully integrated with the standard atomic properties, e.g. automatically available from the keys, haskey and pairs functions, e.g.:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@show haskey(atom, :pseudopotential)\npairs(atom)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Updating an atomic property proceeds similarly. E.g.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nnewatom = Atom(atom; atomic_mass=13u\"u\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"makes a new carbon atom with all properties identical to atom (including custom ones), but setting the atomic_mass to 13 units.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To simplify interoperability some optional properties are reserved. For these:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Throughout the AtomsBase ecosystem these property keys carry a well-defined meaning. I.e. if they are supported by a code, the code expects them to hold the data specified below.\nIf a consuming code cannot make use of these properties, it should at least warn the user about it. For example if a library or simulation code does not support such a feature and drops the respective information it should @warn or (even better) interrupt execution with an error.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Property name Unit / Type Description\n:charge Charge Net charge of the atom\n:covalent_radius Length Covalent radius tabulated for the atom\n:vdw_radius Length VdW radius tabulated for the atom\n:magnetic_moments Union{Float64,Vector{Float64}} Initial magnetic moment\n:pseudopotential String Pseudopotential or PAW keyword or \"\" if Coulomb potential employed","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A convenient way to iterate over all data stored in an atom offers the pairs function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for (k, v) in pairs(atom)\n    println(\"$k  =  $v\")\nend","category":"page"},{"location":"tutorial/#System-interface-and-conventions","page":"Tutorial","title":"System interface and conventions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the atoms are constructed these can be assembled into a system. For example to place a hydrogen molecule into a cubic box of 10Å and periodic boundary conditions, use:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nbox = [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]]u\"Å\"\nboundary_conditions = [Periodic(), Periodic(), Periodic()]\nhydrogen = FlexibleSystem([Atom(:H, [0, 0, 1.]u\"bohr\"),\n                           Atom(:H, [0, 0, 3.]u\"bohr\")],\n                           box, boundary_conditions)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An update constructor for systems is supported as well (see AbstractSystem). For example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AbstractSystem(hydrogen; bounding_box=[[5.0, 0.0, 0.0], [0.0, 5.0, 0.0], [0.0, 0.0, 5.0]]u\"Å\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To update the atomic composition of the system, this function supports an atoms (or particles) keyword argument to supply the new set of atoms to be contained in the system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that in this example FlexibleSystem( ... ) would have worked as well (since we are updating a FlexibleSystem). However, using the AbstractSystem constructor to update the system is more general as it allows for type-specific dispatching when updating other data structures implementing the AbstractSystem interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similar to the atoms, system objects similarly support a functional-style access to system properties as well as a dict-style access:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bounding_box(hydrogen)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hydrogen[:boundary_conditions]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pairs(hydrogen)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover atomic properties of a specific atom or all atoms can be directly queried using the indexing notation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hydrogen[1, :position]  # Position of first atom","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hydrogen[:, :position]  # All atomic symbols","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, supported keys of atomic properties can be directly queried at the system level using atomkeys and hasatomkey. Note that these functions only apply to atomic properties which are supported by all atoms of a system. In other words if a custom atomic property is only set in a few of the contained atoms, these functions will not consider it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atomkeys(hydrogen)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For constructing atomic systems the functions atomic_system, isolated_system, periodic_system are oftentimes more convenient as they provide specialisations for some standard atomic system setups. For example to setup a hydrogen system with periodic BCs, we can issue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nbounding_box = [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]]u\"Å\"\nhydrogen = periodic_system([:H => [0, 0, 1.]u\"bohr\",\n                            :H => [0, 0, 3.]u\"bohr\"],\n                           bounding_box)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To setup a silicon unit cell we can use fractional coordinates (which is common for solid-state simulations):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nbounding_box = 10.26 / 2 * [[0, 0, 1], [1, 0, 1], [1, 1, 0]]u\"bohr\"\nsilicon = periodic_system([:Si =>  ones(3)/8,\n                           :Si => -ones(3)/8],\n                           bounding_box, fractional=true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively we can also place an isolated H2 molecule in vacuum (Infinite box and zero dirichlet BCs), which is the standard setup for molecular simulations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nhydrogen = isolated_system([:H => [0, 0, 1.]u\"bohr\",\n                            :H => [0, 0, 3.]u\"bohr\"])","category":"page"},{"location":"tutorial/#Optional-system-properties","page":"Tutorial","title":"Optional system properties","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similar to atoms, systems also support storing arbitrary data, for example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful, UnitfulAtomic, AtomsBase  # hide\nsystem = isolated_system([:H => [0, 0, 1.]u\"bohr\", :H => [0, 0, 3.]u\"bohr\"]; extra_data=42)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Again these custom properties are fully integrated with keys, haskey, pairs and get.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@show keys(system)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some property names are reserved and should be considered by all libraries supporting AtomsBase if possible:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Property name Unit / Type Description\n:charge Charge Total net system charge\n:multiplicity Int (unitless) Multiplicity of the ground state targeted in the calculation","category":"page"}]
}
